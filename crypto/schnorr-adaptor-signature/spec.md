# BIP0340-compatible Schnorr adaptor signatures

This document describes a Schnorr adaptor signature [(1)][1] [(2)][2] construction
that is compatible with [BIP-0340][3] (Taproot Schnorr signatures).

In brief: an adaptor signature is a two-party signature involving a *signing
party* and a *decrypting party*. The signing party uses its secret signing
key and the decrypting party's public encryption key to create a *pre-signature*,
which can be verified using the public keys of both parties. The decrypting
party can convert the pre-signature into a Schnorr signature that can be
verified using only the signing party's key. Given a pre-signature and the
decrypted signature, anyone can extract the decrypting party's secret.

[1]: <https://download.wpsoftware.net/bitcoin/wizardry/mw-slides/2017-03-mit-bitcoin-expo/slides.pdf>
[2]: <https://eprint.iacr.org/2020/476.pdf>
[3]: <https://github.com/bitcoin/bips/blob/master/bip-0340.mediawiki>

## Overview and notation

Notation in this document is borrowed directly from BIP-0340. (To avoid
transcription errors, we do not reproduce the notation here.) The exception
is that this document uses `tagged_hash("TAG", input)` instead of
`hash_TAG(input)` as in BIP-0340.

An adaptor signature defines five algorithms: KeyGen, EncSign, EncVerify,
Decrypt, and Extract.

### KeyGen

KeyGen is identical to the algorithm defined in BIP-0340.

### EncSign

Inputs:

- The signing key `sk`: a 32-byte array

- The encryption key `ek`: a 32-byte array encoding the X-coordinate of the
  decrypting party's public key. In other words, `ek = bytes(int(dk) * G)`,
  where `dk` is the decryption key.

- The message `m`: a byte array of arbitrary length (see "Messages of
  Arbitrary Size" in BIP-0340 for discussion)

- Auxiliary random data `a`: a uniformly random 32-byte array (see discussion
  in BIP-0340 and below)

The algorithm `EncSign(sk, ek, m, a)` is defined as follows:

1. Let `d' = int(sk)`

2. return FAIL if `d' == 0` or `d' >= n`

3. Let `Pp = d' * G`

4. Let `d = d'` if `has_even_y(Pp)`, otherwise let `d = n - d'`

5. Let `t` be the byte-wise XOR of `bytes(d)` and `tagged_hash("BIP0340/aux", a)`

6. Let `rand = tagged_hash("BIP0340/nonce", t || bytes(Pp) || m)`

7. Let `k' = int(rand) mod n`

8. Return FAIL if `k' == 0`

9. Let `R' = k' * G`

10. Let `(k, Rp) = (k', R')` if `has_even_y(R')`, otherwise let `(k, Rp) = (n - k', -R')`

11. Let `Tp = lift_x(int(ek))`; return FAIL if that fails

12. Compute `RTp` as follows:

  - If `has_even_y(Rp + Tp)`, let `RTp = Rp + Tp`

  - Else if `has_even_y(Rp - Tp)`, let `RTp = Rp - Tp`

  - Else let `a = bytes(k)` and go back to Step 5

(INVARIANT: at the start of Step 13, both Rp and RTp have even y-coordinates)

13. Let `e = int(tagged_hash("BIP0340/challenge", bytes(RTp) || bytes(Pp) || m)) mod n`

14. Let `psig = bytes(Rp) || bytes((k + e * d) mod n)`

15. Return FAIL if `EncVerify(bytes(Pp), ek, m, psig)` fails

16. Return `psig`

#### Rejection sampling `k`: security considerations and alternative approaches

`EncSign` uses rejection sampling for `k` in order to ensure that both `Rp`
and `RTp` have even y-coordinate. This is important for the correctness and
security of the `EncVerify` algorithm (`Rp`) and for Schnorr `Verify` on the
decrypted signature (`RTp`).

Since `k` depends on `sk`, however, it is crucially important to ensure that
the rejection sampling procedure does not leak information about `sk` to an
observer. Calling `EncSign` with a hard-to-guess, non-repeated `a` value
ensures that the number of iterations is essentially independent of `sk`.
In particular, in cases where `a` can be reliably sampled with reasonably
high entropy (e.g., adversary has less than 2^-80 chance of guessing `a`),
the rejection sampling procedure leaks a negligible amount of information
about `sk`.

If `a` cannot be reliably sampled with high entropy (*very* conservatively,
if the adversary has better than 2^-64 chance of guessing `a` correctly),
extra precautions must be taken to ensure that rejection sampling does
not leak information. One approach that prevents leakage is to sample
20 candidate `k'` values, execute Steps 8--13 for each one, and select one
of the suitable candidates (all in constant time), failing if no suitable
candidate is found. A random `k` value will be rejected with probability
1/4, so checking 20 candidates gives a 2^-40 probability of rejection
(30 candidates would give 2^-60, etc.).

The rejection sampling procedure above uses the rejected `k` value in one
iteration as the `a` value in the next iteration. This approach is safe: since
`tagged_hash` is modeled as a random oracle and because `n` is negligibly far
from 2^256, `k` is statistically close to 32 random bytes. Other approaches
are also possible. For example, the `rand` value computed in Step 6 could be
used to seed a cryptographically secure PRG (e.g., ChaCha20) and candidate
`k'` values could then be generated by extracting the next 32 bytes from the
PRG and reducing mod `n`.

### EncVerify

Inputs:

- The signature verification key `pk`: a 32-byte array encoding the
  X-coordinate of the signing party's public key. In other words,
  `pk = bytes(int(sk) * G)`, where `sk` is the signing key.

- The encryption key `ek`: a 32-byte array encoding the X-coordinate
  of the decrypting party's public key.

- The message `m`: a byte array of arbitrary length

- The pre-signature `psig`: a 64-byte array

The algorithm `EncVerify(pk, ek, m, psig)` is defined as follows:

1. Let `Pp = lift_x(int(pk))`; return FAIL if that fails

2. Let `Tp = lift_x(int(ek))`; return FAIL if that fails

3. Let `Rp = lift_x(int(psig[0:32]))`; return FAIL if that fails

4. Let `s = int(psig[32:64])`; return FAIL if `s >= n`

5. Compute `RTp` as follows:

  - If `has_even_y(Rp + Tp)`, let `RTp = Rp + Tp`

  - Else if `has_even_y(Rp - Tp)`, let `RTp = Rp - Tp`

  - Else return FAIL

6. Let `e = int(tagged_hash("BIP0340/challenge", bytes(RTp) || bytes(Pp) || m)) mod n`

7. Let `Rrec = s * G - e * Pp`

8. Return FAIL if `is_infinite(Rrec)`

9. Return FAIL if `not has_even_y(Rrec)`

10. Return FAIL if `x(Rrec) != x(Rp)`

11. Return SUCCESS only if no prior step failed

### Decrypt

Inputs:

- The decryption key `dk`: a 32-byte array such that `bytes(int(dk) * G)`
  is the `ek` value used to generate the signature being decrypted

- The pre-signature `psig`: a 64-byte array

- The signature verification key `pk`: a 32-byte array encoding the
  X-coordinate of the signing party's public key.

- The message `m`: a byte array of arbitrary length

The algorithm `Decrypt(dk, psig, pk, m)` is defined as follows:

1. Let `Rp = lift_x(int(psig[0:32]))`; return FAIL if that fails

2. Let `s = int(psig[32:64])`; return FAIL if `s >= n`

3. Let `u' = int(dk)`

4. Return FAIL if `u' == 0` or `u' >= n`

5. Let `T' = u' * G`

6. Let `(u, Tp) = (u', T')` if `has_even_y(T')`, otherwise let `(u, Tp) = (n - u', -T')`

7. Compute `ss` and `RTp` as follows:

  - If `has_even_y(Rp + Tp)`, let `(ss, RTp) = (s + u, Rp + Tp)`

  - Else if `has_even_y(Rp - Tp)`, let `(ss, RTp) = (s - u, Rp - Tp)`

  - Else return FAIL

8. Let `sig = bytes(RTp) || bytes(ss)`

9. Return FAIL if `Verify(pk, m, sig)` fails, for `Verify` given by BIP-0340.

10. Return `sig`

In other words: if `dk` is the secret value correspnding to the `ek` value
used when creating `psig` for message `m`, then the returned `sig` is a valid
Schnorr signature for message `m` under the signature verification key `pk`
corresponding to the `sk` value used when creating `psig`.

### Extract

Inputs:

- The pre-signature `psig`: a 64-byte array

- The decrypted signature `sig`: a 64-byte array

- The encryption key `ek`: a 32-byte array encoding the X-coordinate
  of the decrypting party's public key.

The algorithm `Extract(psig, sig, ek)` is defined as follows:

1. Let `ss = int(sig[32:64])`

2. Let `s = int(psig[32:64])`

3. Let `dk' = bytes((ss - s) mod n)`

4. Return FAIL if `ek != bytes(int(dk') * G)`

5. Return `dk'`

The value `dk'` returned by `Extract` is equal to either `dk` or `n - dk`
(where `dk` is the value supplied to `Decrypt` to produce `sig` from `psig`).
The polarity of `dk'` generally doesn't matter for Schnorr signing because the
signing algorithm chooses a canonical polarity for `sk` (akin to Steps 3--4 of
the `EncSign` algorithm above).

### Converting a pre-signature to the `schnorr_fun` format

Pre-signatures generated as described in this document are compatible with the
[`schnorr_fun` library][schnorrfun]. That library defines pre-signatures as:

```rust
struct SchnorrFunEncryptedSignature {
    RTp: Point, // schnorr_fun calls this field `R`
    s: Scalar,  // schnorr_fun calls this field `s_hat`
    nn: bool,   // schnorr_fun calls this field `needs_negation`
}
```

This section describes how to convert the output of `EncSign` to this format.

Inputs:

- The pre-signature `psig`: a 64-byte array

- The encryption key `ek`: a 32-byte array encoding the X-coordinate
  of the decrypting party's public key.

Procedure `ConvertToSchnorrFunEncryptedSignature(psig, ek)` is defined as follows:

1. Let `Rp = lift_x(int(psig[0:32]))`; return FAIL if that fails

2. Let `s = int(psig[32:64])`; return FAIL if `s >= n`

3. Let `Tp = lift_x(int(ek))`; return FAIL if that fails

4. Compute `nn` and `RTp` as follows:

  - If `has_even_y(Rp + Tp)`, let `(nn, RTp) = (False, Rp + Tp)`

  - Else if `has_even_y(Rp - Tp)`, let `(nn, RTp) = (True, Rp - Tp)`

  - Else return FAIL

5. Return `(RTp, s, nn)`

[schnorrfun]: <https://github.com/LLFourn/secp256kfun>
